'''
* main.py : Attitude caculator using SO3
*
*          Copyright (C) 2018 by XiaoqiangChen, All rights reserved.
* author  : XiaoqiangChen
* mail    : 309905109@qq.com
* history : 2018/09/26  1.0  new
'''

from CAttitude import Attitude
import math

class SO3Attitude(Attitude):
    """docstring for SO3Attitude"""
    _initialized = False;

    def __init__(self):
        super(SO3Attitude, self).__init__()
        self._gyro_offset_x = 0;
        self._gyro_offset_y = 0;
        self._gyro_offset_z = 0;
        self._gyro_offset_count = 0;
        self.q0 = 1.0;
        self.q1 = 0.0;
        self.q2 = 0.0;
        self.q3 = 0.0;
        self.dq0 = 0.0;
        self.dq1 = 0.0;
        self.dq2 = 0.0;
        self.dq3 = 0.0;
        self.q0q0 = 0.0;
        self.q0q1 = 0.0;
        self.q0q2 = 0.0;
        self.q0q3 = 0.0;
        self.q1q1 = 0.0;
        self.q1q2 = 0.0;
        self.q1q3 = 0.0;
        self.q2q2 = 0.0;
        self.q2q3 = 0.0;
        self.q3q3 = 0.0;
        self.bFilterInit = False;

    def calculateAtt(self):
        lsGyros = zip(self._dataSet._lsDeltT,self._dataSet._lsGyroX,self._dataSet._lsGyroY,self._dataSet._lsGyroZ);
        lsAccs = zip(self._dataSet._lsAcclX,self._dataSet._lsAcclY,self._dataSet._lsAcclZ);
        lsmag = zip(self._dataSet._lsMageX,self._dataSet._lsMageY,self._dataSet._lsMageZ);
        for imu in zip(lsGyros,lsAccs,lsmag):
            if self._initialized == False:
                self._gyro_offset_x += imu[0][1];
                self._gyro_offset_y += imu[0][2];
                self._gyro_offset_z += imu[0][3];
                self._gyro_offset_count += 1;
                if self._gyro_offset_count == 1000:
                    self._initialized = True;
                    self._gyro_offset_x /= self._gyro_offset_count;
                    self._gyro_offset_y /= self._gyro_offset_count;
                    self._gyro_offset_z /= self._gyro_offset_count;
                self._lsPitch.append(None);
                self._lsRoll.append(None);
                self._lsYaw.append(None);
            else:
                gyro_x = imu[0][1] - self._gyro_offset_x;
                gyro_y = imu[0][2] - self._gyro_offset_y;
                gyro_z = imu[0][3] - self._gyro_offset_z;
                acc_x = imu[1][0];
                acc_y = imu[1][1];
                acc_z = imu[1][2];
                mag_x = imu[2][0];
                mag_y = imu[2][1];
                mag_z = imu[2][2];
                dt = imu[0][0];
                self.NonlinearSO3AHRSupdate(gyro_x,gyro_y,gyro_z,acc_x,acc_y,acc_z,mag_x,mag_y,mag_z,dt);

                # Convert q->R, This R converts inertial frame to body frame.
                Rot_matrix0 = self.q0q0 + self.q1q1 - self.q2q2 - self.q3q3;# 11
                Rot_matrix1 = 2.0 * (self.q1*self.q2 + self.q0*self.q3);  # 12
                Rot_matrix2 = 2.0 * (self.q1*self.q3 - self.q0*self.q2);  # 13
                Rot_matrix3 = 2.0 * (self.q1*self.q2 - self.q0*self.q3);  # 21
                Rot_matrix4 = self.q0q0 - self.q1q1 + self.q2q2 - self.q3q3;# 22
                Rot_matrix5 = 2.0 * (self.q2*self.q3 + self.q0*self.q1);  # 23
                Rot_matrix6 = 2.0 * (self.q1*self.q3 + self.q0*self.q2);  # 31
                Rot_matrix7 = 2.0 * (self.q2*self.q3 - self.q0*self.q1);  # 32
                Rot_matrix8 = self.q0q0 - self.q1q1 - self.q2q2 + self.q3q3;# 33

                # 1-2-3 Representation.
                # Equation (290) 
                # Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors, James Diebel.
                #  Existing PX4 EKF code was generated by MATLAB which uses coloum major order matrix.
                euler0 = math.atan2(Rot_matrix5, Rot_matrix8);    # ! Roll
                euler1 = -math.asin(Rot_matrix2);   # ! Pitch
                euler2 = math.atan2(Rot_matrix1, Rot_matrix0);        # ! Yaw
                print(euler2,euler1,euler0);

                self._lsPitch.append(euler1);
                self._lsRoll.append(euler0);
                self._lsYaw.append(euler2);

    def NonlinearSO3AHRSupdate(self,gx:float,gy:float,gz:float,ax:float,ay:float,az:float, \
            mx:float,my:float,mz:float,dt:float):
        if self.bFilterInit == False:
            self.bFilterInit = True;
            self.NonlinearSO3AHRSinit(ax,ay,az,mx,my,mz);

            
    def NonlinearSO3AHRSinit(self,ax:float,ay:float,az:float, mx:float,my:float,mz:float):
        initialPitch,initialRoll = self.accAtt([ax,ay,az]);
        initialHdg = self.magHeading([mx,my,mz],initialPitch,initialRoll);

        cosRoll = math.cos(initialRoll * 0.5);
        sinRoll = math.sin(initialRoll * 0.5);
    
        cosPitch = math.cos(initialPitch * 0.5);
        sinPitch = math.sin(initialPitch * 0.5);
    
        cosHeading = math.cos(initialHdg * 0.5);
        sinHeading = math.sin(initialHdg * 0.5);
    
        self.q0 = cosRoll * cosPitch * cosHeading + sinRoll * sinPitch * sinHeading;
        self.q1 = sinRoll * cosPitch * cosHeading - cosRoll * sinPitch * sinHeading;
        self.q2 = cosRoll * sinPitch * cosHeading + sinRoll * cosPitch * sinHeading;
        self.q3 = cosRoll * cosPitch * sinHeading - sinRoll * sinPitch * cosHeading;
    
        # auxillary variables to reduce number of repeated operations, for 1st pass
        self.q0q0 = self.q0 * self.q0;
        self.q0q1 = self.q0 * self.q1;
        self.q0q2 = self.q0 * self.q2;
        self.q0q3 = self.q0 * self.q3;
        self.q1q1 = self.q1 * self.q1;
        self.q1q2 = self.q1 * self.q2;
        self.q1q3 = self.q1 * self.q3;
        self.q2q2 = self.q2 * self.q2;
        self.q2q3 = self.q2 * self.q3;
        self.q3q3 = self.q3 * self.q3;

def main():
    sensorfile = r'test\09_26_14_sensor_combined_0.csv';
    attfile = r'test\09_26_14_vehicle_attitude_0.csv'
    att = SO3Attitude();
    att.loadData(sensorfile,attfile);
    att.calculateAtt();
    att.showFig();

if __name__ == '__main__':
    main()